<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Top 500 MusicBrainz Editors</title>
 <style>
  :root {
    color-scheme: light dark;
    --bg:#0b0b0c;
    --card:#121316;
    --fg:#e9eaee;
    --muted:#9aa1ac;
    --accent:#6aa3ff;
    --up:#6bdc8b;
    --down:#ff8a8a;
    --same:#9aa1ac;
    --new:#b9c7ff;
  }

  body {
    margin:0;
    font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--fg);
  }

  .wrap {
    max-width:1100px;
    margin:32px auto;
    padding:0 16px;
  }

  header {
    display:flex;
    flex-wrap:wrap;
    align-items:flex-end;
    gap:12px;
    justify-content:space-between;
  }

  h1 {
    font-size:clamp(22px, 3vw, 32px);
    margin:0;
    letter-spacing:.2px;
  }

  .meta {
    color:var(--muted);
    font-size:14px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

  .controls {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
    margin:14px 0 0;
  }

  input[type="search"] {
    padding:10px 12px;
    border-radius:10px;
    border:1px solid #2a2e37;
    background:#0f1114;
    color:var(--fg);
    outline:none;
    min-width:240px;
  }

  .card {
    background:var(--card);
    border:1px solid #1d2129;
    border-radius:16px;
    box-shadow:0 10px 30px rgb(0 0 0 / 25%);
    overflow-x:auto;           /* NEW: horizontal scroll on small screens */
    overflow-y:hidden;
    margin-top:16px;
  }

  table {
    width:100%;
    border-collapse:collapse;
    min-width:600px;           /* NEW: avoid columns squishing too much */
  }

  thead th {
    text-align:left;
    font-weight:600;
    font-size:13px;
    color:var(--muted);
    letter-spacing:.3px;
    padding:14px;
    border-bottom:1px solid #1d2129;
    white-space:nowrap;
  }

  tbody td {
    padding:14px;
    border-bottom:1px solid #1a1d24;
  }

  tbody tr:hover {
    background:#101218;
  }

  .rank {
    width:60px;
    color:#cbd3df;
    font-variant-numeric:tabular-nums;
  }

  .edits, .delta {
    font-variant-numeric:tabular-nums;
    text-align:right;
  }

  .name {
    font-weight:600;
  }

  .footer {
    color:var(--muted);
    font-size:13px;
    margin:12px 2px;
  }

  .link {
    color:var(--accent);
    text-decoration:none;
  }

  .link:hover {
    text-decoration:underline;
  }

  .arrow.up   { color: var(--up); }
  .arrow.down { color: var(--down); }
  .arrow.same { color: var(--same); }
  .arrow.new  { color: var(--new); }

  details {
    margin-top:16px;
  }

  summary {
    cursor:pointer;
    color:var(--muted);
  }

  .legend {
    color:var(--muted);
    font-size:13px;
    margin-left:auto;
    display:flex;
    gap:14px;
    align-items:center;
  }

  .legend span {
    display:inline-flex;
    align-items:center;
    gap:4px;
  }

  /* sortable headers */
  thead th.sortable {
    cursor:pointer;
  }
  thead th.sortable::after {
    content:' â‡…';
    font-size:11px;
    opacity:.5;
  }

  /* ===== Mobile tweaks ===== */
  @media (max-width: 640px) {
    .wrap {
      margin:20px auto;
      padding:0 10px;
    }

    header {
      flex-direction:column;
      align-items:flex-start;
      gap:6px;
    }

    .controls {
      width:100%;
      margin-top:8px;
    }

    input[type="search"] {
      flex:1;
      min-width:0;
      width:100%;
    }

    .legend {
      font-size:12px;
      margin-left:0;
      gap:10px;
    }

    thead th,
    tbody td {
      padding:10px 8px;
      font-size:13px;
    }
  }
</style>

</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Top 500 MusicBrainz Editors</h1>
        <div class="meta">
          <span>Current: <code id="csv-current">top_editors.csv</code> â€¢ <span id="last-updated-current">â€”</span></span>
          <span>Compared to: <code id="csv-old">old_top_editors.csv</code> â€¢ <span id="last-updated-old">â€”</span></span>
        </div>
      </div>
      <div class="controls">
        <input id="q" type="search" placeholder="Filter by editorâ€¦" aria-label="Filter editors" />
        <div class="legend">
          <span><span class="arrow up">â–²</span> up</span>
          <span><span class="arrow down">â–¼</span> down</span>
          <span><span class="arrow same">â†’</span> same</span>
          <span><span class="arrow new">â–² new</span></span>
        </div>
      </div>
    </header>

    <section class="card">
      <table id="table">
        <thead>
          <tr>
            <th class="rank sortable">#</th>
            <th>Editor</th>
            <th class="edits sortable">Edits</th>
            <th class="delta sortable">Î” rank</th>
            <th class="delta sortable">Î” edits</th> 
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="5" style="padding:18px;color:#9aa1ac;">Loadingâ€¦</td></tr>
        </tbody>
      </table>
    </section>

    <details class="card" id="dropped-wrap">
      <summary style="padding:14px 16px;">Show dropped editors (present before, not in current top 500)</summary>
      <div style="padding:0 0 12px;">
        <table>
          <thead>
            <tr>
              <th class="rank">Prev #</th>
              <th>Editor</th>
              <th class="edits">Prev edits</th>
            </tr>
          </thead>
          <tbody id="dropped-body"></tbody>
        </table>
      </div>
    </details>

    <p class="footer">
      Tip: Override files/dates via query string, e.g.
      <code>?csv=top_editors.csv&amp;old=old_top_editors.csv&amp;date=2025-11-04&amp;olddate=2025-10-29</code>
    </p>
  </div>

  <script>
    // ===== Config (CSV filenames + optional config/URL date overrides) =====
    const params = new URL(location.href).searchParams;
    const CSV_CURRENT = params.get('csv') || 'top_editors.csv';
    const CSV_OLD     = params.get('old') || 'old_top_editors.csv';
    const CONFIG_URL  = params.get('config') || 'dump-meta.json'; // optional JSON
    const URL_DATE_OVERRIDE    = params.get('date');    // expects YYYY-MM-DD
    const URL_OLDDATE_OVERRIDE = params.get('olddate'); // expects YYYY-MM-DD
    const MB_USER_URL = (name) => `https://musicbrainz.org/user/${encodeURIComponent(name)}`;

    // ===== Utils =====
    function parseCSV(text) {
      const rows = []; let i=0, field='', row=[], inQuotes=false;
      while (i<text.length) {
        const c=text[i];
        if (inQuotes) {
          if (c === '"') { if (text[i+1] === '"') { field += '"'; i++; } else { inQuotes=false; } }
          else field += c;
        } else {
          if (c === '"') inQuotes = true;
          else if (c === ',') { row.push(field); field=''; }
          else if (c === '\n') { row.push(field); rows.push(row); row=[]; field=''; }
          else if (c !== '\r') field += c;
        }
        i++;
      }
      if (field.length || row.length) { row.push(field); rows.push(row); }
      return rows.filter(r => r.some(cell => cell.trim() !== ''));
    }
    function detectColumns(headerRow) {
      const raw = headerRow, lower = raw.map(h => h.toLowerCase());
      const find = (names) => names.reduce((idx,name)=> idx!==-1?idx:lower.indexOf(name), -1);
      const rankIdx  = find(['rank']);
      const idIdx    = find(['editor_id','id']);
      let   nameIdx  = find(['editor_name','editor','name','user']);
      let   editsIdx = find(['applied_edit_count','edit_count','edits','count']);
      if (nameIdx === -1) nameIdx = 0;
      if (editsIdx === -1) {
        editsIdx = raw.findIndex((h,i)=> i!==nameIdx && !lower[i].includes('id'));
        if (editsIdx === -1) editsIdx = Math.min(1, raw.length-1);
      }
      return { rankIdx, idIdx, nameIdx, editsIdx };
    }
    function cellNum(v) { const n = Number(String(v ?? '').replace(/[, ]/g,'')); return Number.isFinite(n) ? n : null; }
    function formatNumber(n) { const x = Number(n); return Number.isFinite(x) ? x.toLocaleString() : n; }
    function ymd(d) { // format Date -> YYYY-MM-DD (local)
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }

    // ===== Config file / date overrides =====
    async function loadConfig(url) {
      try { const r = await fetch(url, { cache:'no-store' }); if (!r.ok) throw 0; return await r.json(); }
      catch { return null; }
    }
    function normalizeConfigDate(val) {
      // Accept "YYYY-MM-DD" or {label:"...", iso:"..."}; return a display string
      if (!val) return null;
      if (typeof val === 'string') return val.trim();              // e.g. "2025-10-29"
      if (val.label) return String(val.label);                     // show as-is
      if (val.iso)   return String(val.iso).split('T')[0];         // iso -> date part
      return null;
    }
    function isYMD(s) { return typeof s === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(s); }
    function setStamp(codeElId, dateElId, shownUrl, headers, overrideVal) {
      document.getElementById(codeElId).textContent = shownUrl;
      const el = document.getElementById(dateElId);
      // Priority: URL param -> config -> headers
      if (isYMD(overrideVal)) { el.textContent = overrideVal; return; }
      const cfgStr = normalizeConfigDate(overrideVal);
      if (cfgStr) { el.textContent = cfgStr; return; }
      const lastMod = headers?.get?.('Last-Modified') || headers?.get?.('Date');
      el.textContent = lastMod ? ymd(new Date(lastMod)) : '(not provided)';
    }

    // ===== Data loading & transforms =====
    async function fetchCSV(url) {
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error(`${url} â†’ HTTP ${resp.status}`);
      const text = await resp.text();
      const rows = parseCSV(text);
      if (!rows.length) throw new Error(`${url} is empty`);
      return { rows, headers: resp.headers };
    }
    function normalizeTable(rows) {
      const { rankIdx, idIdx, nameIdx, editsIdx } = detectColumns(rows[0]);
      const body = rows.slice(1);
      const items = body.map((r, i) => {
        const id    = idIdx !== -1 ? (cellNum(r[idIdx]) ?? String(r[idIdx]||'').trim()) : null;
        const name  = (r[nameIdx] ?? '').trim();
        const edits = cellNum(r[editsIdx]);
        const rank  = rankIdx !== -1 ? cellNum(r[rankIdx]) : (i+1);
        return { id: id ?? name, editor_id: id, name, edits: edits ?? 0, rank };
      }).filter(x => x.name);
      if (rankIdx === -1) items.sort((a,b)=>(b.edits||0)-(a.edits||0));
      items.forEach((x,i)=> x.rank = i+1);
      return items;
    }
    function computeTrends(curr, prev) {
      const prevByKey = new Map(prev.map(x => [x.id, x]));
      const currByKey = new Map(curr.map(x => [x.id, x]));
      const annotated = curr.map(x => {
        const old = prevByKey.get(x.id);
        if (!old) return { ...x, rank_change:'', edits_change:'', arrow:'â–² new', arrowClass:'new' };
        const rank_change  = old.rank - x.rank; // + means moved up
        const edits_change = (x.edits ?? 0) - (old.edits ?? 0);
        let arrow='â†’', arrowClass='same';
        if (rank_change > 0) { arrow='â–²'; arrowClass='up'; }
        else if (rank_change < 0) { arrow='â–¼'; arrowClass='down'; }
        return { ...x, rank_change, edits_change, arrow, arrowClass };
      });
      const dropped = prev.filter(x => !currByKey.has(x.id)).sort((a,b)=> a.rank - b.rank);
      return { annotated, dropped };
    }

    // ===== Rendering =====
    function renderCurrentTable(items) {
      const tbody = document.getElementById('tbody');
      if (!items.length) { tbody.innerHTML = `<tr><td colspan="5" style="padding:18px;color:#9aa1ac;">No rows.</td></tr>`; return; }
      tbody.innerHTML = items.map(x => `
        <tr>
          <td class="rank">${x.rank}</td>
          <td class="name"><a class="link" href="${MB_USER_URL(x.name)}" target="_blank" rel="noopener">${x.name}</a></td>
          <td class="edits">${formatNumber(x.edits)}</td>
          <td class="delta"><span class="arrow ${x.arrowClass}">${x.arrow}</span> ${x.rank_change === '' ? '' : x.rank_change > 0 ? '+'+x.rank_change : x.rank_change}</td>
          <td class="delta">${x.edits_change === '' ? '' : (x.edits_change > 0 ? '+' : '') + formatNumber(x.edits_change)}</td>
        </tr>
      `).join('');
    }
    function renderDroppedTable(dropped) {
      const tbody = document.getElementById('dropped-body');
      if (!tbody) return;
      if (!dropped.length) { tbody.innerHTML = `<tr><td colspan="3" style="padding:14px;color:#9aa1ac;">None dropped ðŸŽ‰</td></tr>`; return; }
      tbody.innerHTML = dropped.map(x => `
        <tr>
          <td class="rank">${x.rank}</td>
          <td class="name"><a class="link" href="${MB_USER_URL(x.name)}" target="_blank" rel="noopener">${x.name}</a></td>
          <td class="edits">${formatNumber(x.edits)}</td>
        </tr>
      `).join('');
    }
    function hookFilter() {
      const q = document.getElementById('q'), tbody = document.getElementById('tbody');
      q.oninput = () => {
        const needle = q.value.trim().toLowerCase();
        Array.from(tbody.rows).forEach(tr => {
          const name = tr.cells[1]?.innerText.toLowerCase() || '';
          tr.style.display = needle && !name.includes(needle) ? 'none' : '';
        });
      };
    }

    // General table sorting (including last column)
    function getSortValue(td) {
      if (!td) return null;
      const txt = td.innerText.trim();
      if (!txt) return null;

      // Try to extract a signed number (handles "+1,234", "-56", etc.)
      const m = txt.match(/[-+]?\d[\d,]*/);
      if (m) {
        const n = Number(m[0].replace(/,/g, ''));
        if (!Number.isNaN(n)) return n;
      }

      // Fallback: string comparison
      return txt.toLowerCase();
    }

    function hookSorting() {
      const table = document.getElementById('table');
      const tbody = document.getElementById('tbody');
      const headers = table.querySelectorAll('thead th.sortable');
      let sortState = { idx: null, dir: 1 }; // 1 = asc, -1 = desc

      headers.forEach(th => {
        th.addEventListener('click', () => {
          const idx = th.cellIndex;
          if (sortState.idx === idx) {
            sortState.dir = -sortState.dir; // toggle direction
          } else {
            sortState.idx = idx;
            sortState.dir = 1;
          }

          const rows = Array.from(tbody.rows);
          rows.sort((a, b) => {
            const va = getSortValue(a.cells[idx]);
            const vb = getSortValue(b.cells[idx]);

            if (va == null && vb == null) return 0;
            if (va == null) return 1;
            if (vb == null) return -1;

            if (typeof va === 'number' && typeof vb === 'number') {
              return (va - vb) * sortState.dir;
            }
            return String(va).localeCompare(String(vb)) * sortState.dir;
          });

          rows.forEach(tr => tbody.appendChild(tr));

          // Re-apply current filter if needed
          const q = document.getElementById('q');
          if (q && q.value) {
            q.oninput();
          }
        });
      });
    }

    // ===== Init =====
    (async function init() {
      try {
        // Optional config
        const cfg = await loadConfig(CONFIG_URL);
        const cfgCur = cfg?.current ?? null; // may be "YYYY-MM-DD" or object
        const cfgOld = cfg?.old ?? null;

        // Load CSVs
        const [curr, prev] = await Promise.all([fetchCSV(CSV_CURRENT), fetchCSV(CSV_OLD)]);

        // Set dates: URL > config > headers (all shown as YYYY-MM-DD)
        setStamp('csv-current', 'last-updated-current', CSV_CURRENT, curr.headers, URL_DATE_OVERRIDE || cfgCur);
        setStamp('csv-old',     'last-updated-old',     CSV_OLD,     prev.headers, URL_OLDDATE_OVERRIDE || cfgOld);

        // Build/compare
        const currItems = normalizeTable(curr.rows).sort((a,b)=>(b.edits||0)-(a.edits||0)).slice(0,500)
                              .map((x,i)=>({ ...x, rank:i+1 }));
        const prevItems = normalizeTable(prev.rows);
        const { annotated, dropped } = computeTrends(currItems, prevItems);

        renderCurrentTable(annotated);
        renderDroppedTable(dropped);
        hookFilter();
        hookSorting(); // NEW: enable click-to-sort, including last column
      } catch (err) {
        document.getElementById('tbody').innerHTML =
          `<tr><td colspan="5" style="padding:18px;color:#ffb4b4;">${String(err)}</td></tr>`;
        const dropped = document.getElementById('dropped-body');
        if (dropped) dropped.innerHTML = '';
      }
    })();
  </script>
</body>
</html>
